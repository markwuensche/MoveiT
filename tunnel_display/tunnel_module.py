import os
import cv2
import numpy as np
import random
import moderngl

# Extra padding so the closest tunnel segment never intersects the near clipping
# plane. Without this offset, the recycle loop mode causes the front face to be
# exactly at z=0 which leads to white bars.
FRONT_OFFSET = 0.11
# Recycle a segment only after it is completely behind the camera.
# Waiting ensures the segment stays visible until its back end passes
# the viewer which avoids white flashes when recycling.

def generate_filename(params):
    """Create a descriptive file name from tunnel parameters.

    The previous implementation only used the resolution, which caused files
    generated by :mod:`batch_exporter` to overwrite each other.  The new naming
    scheme includes the tunnel dimensions, segment length, duration and speed so
    that each parameter combination results in a unique filename.
    """

    mode = 'bw' if params['color_mode'] == 'bw' else 'col'
    brightness = {
        'alternating': 'alt',
        'random': 'rnd',
        'monotonous': 'mono'
    }[params['segment_brightness']]
    markers = params['depth_markers']

    recycle = 'recy' if params.get('recycle_loop') else 'norecy'

    return (
        f"tunnel_{params['tunnel_width']:.1f}w_"
        f"{params['tunnel_height']:.1f}h_"
        f"{params['segment_length']:.1f}l_"
        f"{params['tunnel_depth']:.0f}d_"
        f"{params['duration']:.1f}s_"
        f"{params['speed']:.1f}spd_"
        f"{recycle}_"
        f"{mode}_{brightness}_{markers}.mp4"
    )

def default_params():
    return {
        'resolution': (1920, 1080),
        'tunnel_width': 2.0,
        'tunnel_height': 2.0,
        'segment_length': 10.0,
        'depth_markers': 'wireframe',
        'duration': 5.0,
        'speed': 5.0,
        'color_mode': 'bw',
        'segment_brightness': 'alternating',  # 'alternating', 'random', 'monotonous'
        'shaded': True,  # Enable shading for depth perception
        'fps': 60,
        'fovy': 5.0,
        'tunnel_depth': 1000.0,
        'back_plane_color': 0.8,
        'auto_back_plane_color': False,
        'color_palette': 'orange',
        'color_rgb': (0.2, 1/3, 1.0),
        'brightness_contrast': 0.2,
        'recycle_loop': True,
        'square': True,
    }

def apply_contrast(value, contrast):
    adjusted = 0.5 + (value - 0.5) * contrast
    return max(0.0, min(1.0, adjusted))

def generate_brightness(index, mode, contrast):
    """Generate a brightness value for a segment."""
    if mode == 'alternating':
        val = 1.0 if index % 2 == 0 else 0.2
    elif mode == 'random':
        val = random.uniform(0.2, 1.0)
    else:
        val = 1.0
    return apply_contrast(val, contrast)

def create_tunnel_segments(width, height, seg_length, num_segments, brightness_mode, contrast, front_offset=FRONT_OFFSET):
    segments = []
    for i in range(num_segments):
        # Offset by a small amount so the first segment stays in front of the
        # near plane even when recycle_loop pushes a segment to z=0.
        z = -i * seg_length - front_offset
        brightness = generate_brightness(i, brightness_mode, contrast)
        segments.append({'z': z, 'brightness': brightness})
    return segments

def validate_params(params):
    """Basic sanity checks for tunnel parameters."""
    if params['segment_length'] <= 0:
        raise ValueError('segment_length must be positive')

    if params['tunnel_depth'] <= 0:
        raise ValueError('tunnel_depth must be positive')
    if params['segment_length'] > params['tunnel_depth']:
        raise ValueError('segment_length cannot exceed tunnel_depth')
    if params['duration'] <= 0:
        raise ValueError('duration must be positive')

    if params['speed'] < 0:
        raise ValueError('speed must be non-negative')
    if (not params.get('recycle_loop') and
            params['speed'] * params['duration'] > params['tunnel_depth']):
        raise ValueError('camera travels beyond tunnel depth; enable recycle_loop or adjust speed/duration/depth')

class TunnelRenderer:
    @staticmethod
    def compute_resolution(params):
        """Return the actual render resolution based on the square flag."""
        width, height = params['resolution']
        if params.get('square'):
            side = min(width, height)
            return side, side
        return width, height

    def __init__(self, params):
        validate_params(params)
        self.params = params
        self.width, self.height = self.compute_resolution(params)
        self.depth_mode = params['depth_markers']
        self.ctx = moderngl.create_standalone_context()
        self.ctx.line_width = 1.0
        self.ctx.enable(moderngl.BLEND)
        self.ctx.blend_func = (moderngl.SRC_ALPHA, moderngl.ONE_MINUS_SRC_ALPHA)
        # Framebuffer and frame array reused for each frame to reduce allocations
        self.fbo = self.ctx.simple_framebuffer((self.width, self.height))
        self.frame = np.empty((self.height, self.width, 3), dtype=np.uint8)

        self.vertex_shader_src = """#version 330
        in vec3 in_position;
        out vec3 v_pos;
        uniform mat4 model;
        uniform mat4 projection;
        void main() {
            v_pos = in_position;
            gl_Position = projection * model * vec4(in_position, 1.0);
        }
        """

        self.fragment_shader_src = """#version 330
        in vec3 v_pos;
        out vec4 fragColor;

        uniform float brightness;
        uniform bool shaded;
        uniform bool color_mode;
        uniform vec3 base_color;
        uniform float seg_z;

        void main() {
            float shade = 1.0;
            if (shaded) {
                float edge_dist = min(min(abs(v_pos.x), abs(v_pos.y)), abs(v_pos.z));
                shade = 0.5 + 0.5 * edge_dist;
            }
            float fade = smoothstep(-10.0, -400.0, seg_z);
            shade *= (1.0 - fade);
            vec3 base = color_mode ? base_color : vec3(1.0);
            fragColor = vec4(base * brightness * shade, 1.0);
        }
        """

        self.back_fragment_shader_src = """#version 330
        in vec3 v_pos;
        out vec4 fragColor;
        uniform float brightness;
        uniform bool color_mode;
        uniform vec3 base_color;
        void main() {
            vec3 base = color_mode ? base_color : vec3(1.0);
            fragColor = vec4(base * brightness, 1.0);
        }
        """

        self.prog = self.ctx.program(
            vertex_shader=self.vertex_shader_src,
            fragment_shader=self.fragment_shader_src,
        )

        self.mvp = self.prog['model']
        self.projection = self.prog['projection']
        self.brightness = self.prog['brightness']
        self.seg_z = self.prog['seg_z']
        self.shaded = self.prog['shaded']
        self.color_mode = self.prog['color_mode']
        self.base_color = self.prog['base_color']

        self.back_prog = self.ctx.program(
            vertex_shader=self.vertex_shader_src,
            fragment_shader=self.back_fragment_shader_src,
        )
        self.back_model = self.back_prog['model']
        self.back_proj = self.back_prog['projection']
        self.back_brightness = self.back_prog['brightness']
        self.back_color_mode = self.back_prog['color_mode']
        self.back_base_color = self.back_prog['base_color']

        visible_margin = params['segment_length'] * 5
        if params['recycle_loop']:
            self.num_segs = int(params['tunnel_depth'] / params['segment_length']) + 1
        else:
            camera_travel = params['speed'] * params['duration']
            effective_depth = max(params['tunnel_depth'], camera_travel + visible_margin)
            self.num_segs = int(effective_depth / params['segment_length']) + 1

        self.segments = create_tunnel_segments(
            params['tunnel_width'], params['tunnel_height'],
            params['segment_length'], self.num_segs,
            params['segment_brightness'], params['brightness_contrast'],
            FRONT_OFFSET
        )
        self.generated_count = len(self.segments)
        self.brightness_list = [s['brightness'] for s in self.segments]

        if self.params.get('auto_back_plane_color'):
            avg = float(np.mean(self.brightness_list))
            self.params['back_plane_color'] = avg
            hex_val = '#{0:02X}{0:02X}{0:02X}'.format(int(avg * 255))
            print(f"Auto back plane color set to {hex_val}")

        self.init_geometry()

    def init_geometry(self):
        w, h, l = self.params['tunnel_width'], self.params['tunnel_height'], self.params['segment_length']
        vertices = np.array([
            [-w/2, -h/2, 0], [ w/2, -h/2, 0], [ w/2,  h/2, 0], [-w/2,  h/2, 0],
            [-w/2, -h/2, -l], [ w/2, -h/2, -l], [ w/2,  h/2, -l], [-w/2,  h/2, -l],
        ], dtype='f4')
        faces = [[0,1,5,4],[2,3,7,6],[0,3,7,4],[1,2,6,5]]  # side faces only
        tris, edges = [], []

        for face in faces:
            tris.extend([vertices[face[0]], vertices[face[1]], vertices[face[2]],
                         vertices[face[2]], vertices[face[3]], vertices[face[0]]])
            for i in range(4):
                a = vertices[face[i]]
                b = vertices[face[(i + 1) % 4]]
                edges.append(a)
                edges.append(b)

        self.vertex_data = np.array(tris, dtype='f4')
        vbo = self.ctx.buffer(self.vertex_data.tobytes())
        self.vao = self.ctx.simple_vertex_array(self.prog, vbo, 'in_position')

        # Wireframe program and geometry
        self.line_prog = self.ctx.program(
            vertex_shader=self.vertex_shader_src,
            fragment_shader="#version 330\nout vec4 fragColor; void main() { fragColor = vec4(0.0, 0.0, 0.0, 1.0); }"
        )
        self.line_model = self.line_prog['model']
        self.line_proj = self.line_prog['projection']
        edge_data = np.array(edges, dtype='f4')
        line_vbo = self.ctx.buffer(edge_data.tobytes())
        self.line_vao = self.ctx.simple_vertex_array(self.line_prog, line_vbo, 'in_position')

        back_vertices = np.array([
            [-w/2, -h/2, 0], [w/2, -h/2, 0], [w/2, h/2, 0],
            [w/2, h/2, 0], [-w/2, h/2, 0], [-w/2, -h/2, 0]
        ], dtype='f4')
        back_vbo = self.ctx.buffer(back_vertices.tobytes())
        self.back_vao = self.ctx.simple_vertex_array(self.back_prog, back_vbo, 'in_position')

    def render_frame(self, cam_z):
        self.depth_mode = self.params.get('depth_markers', 'none')
        aspect = self.width / self.height
        # Field of view is configurable so users can control perceived depth.
        fovy_deg = self.params.get('fovy', 45.0)
        fovy = np.radians(fovy_deg)
        f = 1.0 / np.tan(fovy / 2)
        near, far = 0.1, self.params['tunnel_depth'] + 10.0
        proj = np.array([
            [f/aspect,0,0,0],
            [0,f,0,0],
            [0,0,(far+near)/(near-far),2*far*near/(near-far)],
            [0,0,-1,0]
        ], dtype='f4')
        self.projection.write(proj.T.tobytes())
        self.back_proj.write(proj.T.tobytes())

        fbo = self.fbo
        fbo.use()
        c = self.params['back_plane_color']
        fbo.clear(c, c, c, 1)

        model = np.eye(4, dtype='f4')
        model[2, 3] = cam_z - self.params['tunnel_depth']
        self.back_model.write(model.T.tobytes())
        self.back_brightness.value = self.params['back_plane_color']
        self.back_color_mode.value = self.params['color_mode'] == 'color'
        self.back_base_color.value = self.params['color_rgb']
        self.back_vao.render()

        tunnel_span = self.params['segment_length'] * len(self.segments)

        for seg in self.segments:
            rel_z = seg['z'] + cam_z
            self.seg_z.value = rel_z

            if self.params.get('recycle_loop'):
                # Wait until the entire segment has passed the camera before
                # recycling it. This avoids visible popping or white flashes as
                # the front face intersects the near plane.
                recycle_after = self.params['segment_length'] + FRONT_OFFSET
                while rel_z > recycle_after:
                    seg['z'] -= tunnel_span
                    seg['brightness'] = generate_brightness(
                        self.generated_count,
                        self.params['segment_brightness'],
                        self.params['brightness_contrast'],
                    )
                    self.generated_count += 1
                    rel_z = seg['z'] + cam_z
            else:
                if rel_z > self.params['segment_length']:
                    continue

            model = np.eye(4, dtype='f4')
            model[2, 3] = rel_z
            self.mvp.write(model.T.tobytes())
            self.brightness.value = seg['brightness']
            self.shaded.value = self.depth_mode in ['shaded', 'both']
            self.color_mode.value = self.params['color_mode'] == 'color'
            self.base_color.value = self.params['color_rgb']
            self.vao.render()

            if self.depth_mode in ['wireframe', 'both']:
                self.line_model.write(model.T.tobytes())
                self.line_proj.write(proj.T.tobytes())
                self.line_vao.render(mode=moderngl.LINES)

        self.ctx.finish()
        fbo.read_into(self.frame, components=3)
        # Flip vertically and convert to BGR
        return cv2.cvtColor(self.frame[::-1], cv2.COLOR_RGB2BGR)

    def update_segments_and_geometry(self):
        visible_margin = self.params['segment_length'] * 5
        if self.params.get('recycle_loop'):
            self.num_segs = int(self.params['tunnel_depth'] / self.params['segment_length']) + 1
        else:
            camera_travel = self.params['speed'] * self.params['duration']
            effective_depth = max(self.params['tunnel_depth'], camera_travel + visible_margin)
            self.num_segs = int(effective_depth / self.params['segment_length']) + 1

        self.segments = create_tunnel_segments(
            self.params['tunnel_width'], self.params['tunnel_height'],
            self.params['segment_length'], self.num_segs,
            self.params['segment_brightness'], self.params['brightness_contrast'],
            FRONT_OFFSET
        )
        self.generated_count = len(self.segments)
        self.brightness_list = [s['brightness'] for s in self.segments]

        if self.params.get('auto_back_plane_color'):
            avg = float(np.mean(self.brightness_list))
            self.params['back_plane_color'] = avg
            hex_val = '#{0:02X}{0:02X}{0:02X}'.format(int(avg * 255))
            print(f"Auto back plane color set to {hex_val}")
        self.init_geometry()

    def reinitialize(self, params=None):
        """Rebuild the tunnel with updated parameters."""
        if params:
            validate_params(params)
            self.params = params
        self.width, self.height = self.compute_resolution(self.params)
        self.depth_mode = self.params.get('depth_markers', 'none')
        self.fbo.release()
        self.fbo = self.ctx.simple_framebuffer((self.width, self.height))
        self.frame = np.empty((self.height, self.width, 3), dtype=np.uint8)

        visible_margin = self.params['segment_length'] * 5
        if self.params.get('recycle_loop'):
            self.num_segs = int(self.params['tunnel_depth'] / self.params['segment_length']) + 1
        else:
            camera_travel = self.params['speed'] * self.params['duration']
            effective_depth = max(self.params['tunnel_depth'], camera_travel + visible_margin)
            self.num_segs = int(effective_depth / self.params['segment_length']) + 1

        self.segments = create_tunnel_segments(
            self.params['tunnel_width'], self.params['tunnel_height'],
            self.params['segment_length'], self.num_segs,
            self.params['segment_brightness'], self.params['brightness_contrast'],
            FRONT_OFFSET
        )
        self.generated_count = len(self.segments)
        self.brightness_list = [s['brightness'] for s in self.segments]

        if self.params.get('auto_back_plane_color'):
            avg = float(np.mean(self.brightness_list))
            self.params['back_plane_color'] = avg
            hex_val = '#{0:02X}{0:02X}{0:02X}'.format(int(avg * 255))
            print(f"Auto back plane color set to {hex_val}")
        self.init_geometry()

    def release(self):
        """Release OpenGL resources."""
        self.fbo.release()
        self.ctx.release()
